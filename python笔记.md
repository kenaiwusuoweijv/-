**input**(打印内容)：信息的输入

​		————**得到的信息永远是字符串**；

**if** 要判断的条件：

​	条件成立时，要做的事

else

​	不满足时，要做的事情      ————缩进表示属于if范围

if elif else 语句 elif可以写多个 互斥且有序

嵌套结构：if elif else可以自由组合，满足缩进要求即可。

**while** 条件：

​		执行1.....

.......，end=' ‘表示不换行；

/t是制表符，可以对齐。/n是换行符。

**for**循环为轮询机制，将“待办事项”逐个完成(遍历循环)

for 变量 in 被处理数据:

​		执行语句

------

**格式化****：

print("  %s   "%("    "))

%表示要占位，s表示占位的变量。单个变量不用括号

%s-字符串；%d-整数；%f-浮点数

精度控制：
		用m，n形式进行控制，m表示控制整数位数，n表示控制小数精度。例如：%5.2f

字符串快速格式化方法：用f" 文本信息{变量}”进行；

表达式：一条具有明确执行结果的代码语句。（可使用字符串格式化方式进行格式化）

-------------------------------------------------------------------------------------

**range**语法

1：`range(num)`	获取从0到这个数的数字序列(不包括这个数本身)；

2：`range(num1 , num2)`	从num1到num2的数字序列(不包括num2)；

3：`range(num1 , num2 , step)`	新增步长(step)，默认为0；

continue:中断本次循环，直接进入下一次循环；

break:直接结束循环；

-------------------------------------------------------------------------------------

**函数**：组织好的，可重复使用的，用来实现特定功能的代码段；

函数的定义：

def	函数名(传入参数)：

​		"'

​		函数说明

​		：param 传入参数 ：形参x的说明

​		：return ：返回值的说明

​		'"

​		函数体

​		return	返回值(默认None)

——参数与返回值可以省略

函数嵌套调用：一个函数里面又调用了另外一个函数

global 关键字：在函数内部声明变量为全局变量；

-------------------------------------------------------------------------------------

**列表**(list)：			————my_list = [ x , y , z ]

​		存储多个数据，可以为不同元素类型，支持嵌套。

列表下标索引从0开始(正向)，反向索引从最后面的元素开始，从-1开始依次递减。如果是嵌套列表，则写两次即可，例：list[1][0]

方法仅使用方法与函数不同。student = Student()；

*list方法*：

1.列表.index(元素): 查找指定元素在列表的下标；

2.列表[下标] = 值: 修改特定位置(索引)的元素值;

3.列表.insert(下标，元素): 在指定的下标位置，插入指定的元素；

4.列表.append(元素): 将指定元素，追加到列表的尾部；

5.列表.extend(其它数据容器): 将其它数据容器的内容取出，依次追加到列表尾部；

6.删除：语法1：del 列表[下标]

​			  语法2：列表.pop(下标) ——>将删除的元素返回，可接收

7.列表.remove(元素)：删除某元素在列表中的第一个匹配项

8.列表.clear()：将列表清空

9.列表.count(元素)：统计某元素在列表内的数量；

10.len(列表)：统计列表中共有多少个元素；

list*遍历*:使用for循环或while循环

**元组**(touple)————不可修改的数据容器,且支持下标索引  例如：my_touple = (   ...   )

​		元组里面嵌套的列表等可变容器内元素可以修改

**字符串**是字符的容器，一个字符可以存放任意数量的字符

字符串的替换：

语法：字符串.replace(字符串1，字符串2)

功能：将字符串内的全部：字符串1，替换为字符串2；

**注意**：不是修改，而是得到了一个新的字符窜

字符串的分割：
语法：字符串.split(分隔符字符串)；

​			————分隔符字符串指按照什么来分割，例如字符串里有空格就可以用split("   ")

功能：按照指定的分隔符字符串，将字符串分为多个字符串，并存入列表对象中；

注意：字符串本身不变，而是得到了一个列表对象

字符串的规整操作(去前后空格)

​		语法：字符串.strip()

字符串的规整操作（去前后指定字符串）

语法：字符串.strip(指定字符串)

​		————假设传入的是12，则1和2都会被去掉

字符串特点：只存储字符串，且不可以修改

序列的常用操作 - **切片**——从一个序列中，取出一个子序列

语法：序列[起始下标:结束下标:步长]

（1	起始下标留空表示从头开始；

（2	结束下标（不含）表示何处结束，可以留空视作截取到结尾；

（3	步长为负数表示反向取（注意起始下标和结束下标也要反向标记）

**集合(set)**：		————{ ， ，}

主要特性：不可重复（自带去重功能），无序

常用修改操作(不支持下标索引):

添加：集合.add(元素)

移除：集合.remove(元素)

取出：集合.pop()：从集合中随机取出一个元素并将其在原集合中删除

清空：集合.clear()

取出2个集合的差集：
语法：集合1.difference(集合2)，功能：取出集合1和集合2的差集（集合1有而集合2没有）

结果：得到一个新集合，集合1和集合2不变

消除2个集合的差集：
语法：集合1.difference_update(集合2)

功能：删除集合1内与集合2相同的元素，集合2不变

2个集合合并：
语法：集合1.union(集合2)

结果：得到新集合，集合1和集合2不变

**字典**的定义：			————同集合一样，key不允许重复，后加的值会覆盖前一位
		同样使用{}，不过存储的元素是一个个的：键值对——>key: value

定义方法：1.my_dict = {}

​				  2.my_dict = dict()

通过dict(key)来查询value，dict(value)查询key

字典的Key和Value可以是任意数据类型（Key不可为字典）————所以，字典是可以嵌套的

从嵌套中获取数据my.dict[key1][key2]

常用操作：

新增（更新）元素

​		语法：字典[Key] = Value————Key不存在为新增，存在为更新

删除用pop(Key)，清空用clear()，计算元素数量用len()

获取全部的key：字典.keys()

![](C:\Users\Seagull\Pictures\Screenshots\屏幕截图(10).png)

数据容器的通用操作：

len(容器)：统计容器的元素个数

max(容器)：统计容器的最大元素

min(容器)：统计容器的最小元素

通用容器的转换：字典转化为其它容器时，将Value全都抛弃掉，只保留Key

容器通用排序功能：

​		`sorted(容器，[reverse=True])`————加了reverse=true是反转排序

注意：排序之后的所有数据会放在列表中，则字典会丢失Value

字符串比较：按位比较，从前开始，只要有一位大那么整体就大（比较的ASCll码值）

多个返回值，return后用逗号隔开：return 1 , 2 ；用两个变量接收 x, y = test_return    ———按照顺序接收

**位置参数**：调用函数时根据函数定义的参数位置来传递参数

`def user_info(name, age, gender):`

​		`print(f'您的名字是{name}, 年龄是{age}, 性别是{gender}')`

`user_info('TOM', 20, '男')`

**关键字参数**：函数调用时通过“键=值”形式传递参数——可以不管定义时的位置

`def user_info(name, age, gender):`

​		`print(f'您的名字是{name}, 年龄是{age}, 性别是{gender)`

`user_info(name='小明', age=20, gender='男')`

***特***：还可以使用位置参数和关键字参数混合调用的方式，但位置参数必须放在关键字参数的前面

`user_info(20, name='小明', gender='男')`

**缺省参数**：缺省参数也叫默认参数，用于定义函数，为参数提供默认值，调用函数时可不传该默认参数的值，**注**：(所有位置参数必须出现在默认参数前，包括函数定义和调用)

`def user_info(name, age, gender='男'):`

​		`print(f'您的名字是{name}, 年龄是{age}, 性别是{gender)`

`user_info('TOM', 20)`

`user_info('Rose', 18, '女')`

**不定长参数**：不定长参数也叫可变参数，用于不确定调用的时候会传递多少个参数（不传参也可以）时的场景

*1*.位置传递

`def user_info(*args):`

​		`print(args)`

`user_info('TOM')`

`user_info('TOM', 18)`

注意：传进的所有参数都会被args变量收集，它会根据传进参数的位置合并为一个元组(touple), args是元组类型，这就是位置传递

*2*.关键字传递

`def user_info(**kwargs):`

​		`print(kwargs)`

`user_info(name='TOM', age=18, id=110)`

注意：参数是“键=值”形式的情况下，所有的“键=值”都会被kwargs接受，同时会根据“键=值”组成字典

函数也可以作为参数传递：

​		这是一种计算逻辑的传递，而非数据的传递

`def test_func(compute):`

​		`result = compute(1, 2)`

​		`print(result)`

`def compute(x, y):`

​		`return x + y`

-------------------------------------------------------------------------------------

函数的定义中：

def关键字，可以定义带有名称的函数，可以重复使用

lambda关键字，可以定义匿名函数，只可以临时使用一次

匿名函数定义语法：lambda 传入参数: 函数体（一行代码）

-------------------------------------------------------------------------------------

内容——>编码——>二进制			默认编码：UTF-8

**文件**操作步骤：
1.打开文件

1）open()打开函数：open(name, mode, encording)

​	name:是要打开的目标文件名的字符串（可以包含文件所在的具体路径）

​	mode:设置打开文件的模式（访问模式）：只读、写入、追加等

​	encoding:编码格式（推荐使用UTF-8)

示例：`f = open('python.txt', 'r', encoding=” UTF-8)`     r：只读；w：重写；a：追加

2.读写文件

读：<1>read()方法：文件对象.read(num)

​		num表示要从文件中读取的数据的长度（单位是字节），如果没有传入num，就传入文件的所有数据

​		<2>readlines()方法：

​		readlines可以按照行的方式把整个文件的内容进行一次性读取，并返回一个列表，其中每一行的数据为一个元素

​		<3>readline()方法：

​		一次读取一行内容；

​		<4>可以用for循环来读取文件行

文件写入：`f.write('hello world')`——写入内存（缓冲区）中

内容刷新：`f.flush()`——将内存内容写入文件中		#close()方法内置了flush()

注意：'a'和'w'模式如果文件不存在，会直接创建

3.关闭文件————如果不关闭，文件会一直占用

close()关闭文件对象

4.with open 语法

`with open("python.txt", "r")as f:`

​	`f.readlines()`

通过在with open的语句块中对文件进行操作，可以在操作完成后自动关闭close文件，避免遗忘掉close方法

-------------------------------------------------------------------------------------

**异常**：程序运行的过程中出现了错误		#bug--历史上的小虫子

捕获异常：提前假设某处会出现异常，做后续处理，提醒并让程序继续运行

基本语法：
try:

​	可能发生错误的代码

except:
	如果出现异常需要执行的代码

**捕获指定异常**：

try:

​	....

except	...Error	as	e:			----...Error是错误类型，as e是将e作为异常的别名

​	....

捕获多个异常：例：**except(NameError, ZeroDivisionError)**[as  e]:用元组定义多种异常

捕获所有异常：1.基础写法

​							2.except	Exception	as	e:

可用写法：try:	except:	else:	finally:-->finally无论是否出现异常都会执行

异常的传递：假设前面的函数出现了异常，并且没有被捕获，那么异常就会被传给下一个函数，当所有函数都没有捕获异常时，程序就会报错。

-------------------------------------------------------------------------------------

**模块**：一个Python文件，以.py结尾，能定义函数，类和变量，也能包含可执行代码，可以直接拿来使用（导入模块去使用）

模块的**导入方式**：		--使用前要导入，也可以只导入一个功能

​		[from 模块名]	import	[模块 | 类 | 变量 | 函数 | *]	[as 别名]--注：[]里的内容可省略

​		通过. 使用模块内的全部功能

​		*表示所有，意思是可以使用模块的所有功能

​		取别名的作用是将某一个模块或功能的名字进行更改，之后方便使用

​		自定义模块：自己写一个python文件，进行导入，要注意文件命名规则。

​		导入不同模块的同名功能，以后导入的为准

​		**原本**当模块里有执行语句时，我们直接导入会执行那个语句，但是如果将执行语句放进main里（`if  _ __name_ _ _ == '_ _ main _ _':``）时，只可在模块内部执行，导入后不可执行

​		**如果**一个模块文件中有`__all__`变量，当使用`from xxx import *`时只导入这个列表中的元素

-------------------------------------------------------------------------------------

Python包：从物理上看就是一个文件夹，里面包含了一个__init__.py 文件，该文件夹可用于包含多个模块文件，but从逻辑上看，包的本质依然是模块

**导入包**：

方式一：

​		import 包名.模块名

​		包名.模块名.目标

方式二：
		from 包名/包名.模块名 import 模块名/功能

安装第三方包-pip：

​		打开命令提示符程序，在里面输入：pip	install	包名称--国外网站下载慢

​		若想连接国内网站，输入：

​			pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 包名称

安装第三方包-PyCharm:去设置界面安装

-------------------------------------------------------------------------------------

**对象：**

总面向对象编程：构建类，以类的对象去运行。

1.设计类	-设计表格

类的使用语法：

​	class 类名称：

​		类的属性			————即定义在类中的变量（成员变量）

​		类的行为			————即定义在类中的函数（成员方法）

创建类对象的语法：

​		对象 = 类名称()

成员方法的定义语法：

​		def 方法名(self，形参1，......，形参N)

​				方法体

​		self关键字：

​		· 表示类对象自身的意思

​		· 当我们使用类对象调用方法时，self会自动被python传入

​		· 在方法内部，想要访问类的成员变量，必须使用self

在传入参数时，self是透明的，无需理会

2.创建对象	-打印表格

3.对象属性进行赋值	-填写表格

4.获取对象中记录的信息

**类内置（魔术方法）的方法**：

一.	Python类可以使用：__init__()方法，称之为构造方法

​			可以实现：

​			·在创建类对象（构造类）的时候，会自动执行

​			·在创建类对象（构造类）的时候，将传入参数自动传递给__init__方法使用

例：	`def	 __init__(self,	name,	age,	tel):`

​						`self.name	=	name`

​						`self.age	=	age`

​						`sef.tel	=	tel`

当使用self.name = name时已完成name = None的定义，所以该函数可以省略不写

二.	`__str__`字符串方法：当类对象需要被转换为字符串之时，会输出地址值，使用该方法可以控制类转换为字符串

`def __str__(self):`

​	`return f"student类对象，name={self.name}，age={self.age}"`

三.	`__lt__`小于符号比较方法：实现小于符号 和 大于符号 两种比较						

`def __lt__(self, other):`

​	`return self.age < other.age`

传入参数：other，另一个类对象

返回值：True 或 False

四. `__le__`，小于等于比较符号方法，使用方法基本与`__lt__`方法相同

五. `__eq__`，比较运算符实现方法（ stu1 == stu2）--假设没有实现此魔术方法，则默认比较地址值

-------------------------------------------------------------------------------------

面向对象的三大特性：封装，继承，多态

**封装**：将现实中的事物去映射到程序中的类的一种思想

为了实现不公开的属性和行为，只用于内部使用，提供了私有成员的形式来支持：

· 私有成员变量：变量名以__开头（2个下划线）

· 私有成员方法：方法名以__开头（2个下划线）

私有成员无法被类对象使用，但是可以被类中的其它的成员使用

**继承**：将已有的类拿过来继续使用

**单继承**：`class 类名(父类名):`

​					`类内容体`

**多继承：**`class 类名(父类1，父类2，......，父类N)`

​						`类内容体`

如果不想写类内容体，可以写一个pass，表示空

假设继承的父类有同名的成员方法，以先继承的为主（左边的先）

复习和调用父类成员：
		将父类的成员重新定义一遍即可

一旦复写后直接调用只会调用复写后的成员，如果还想调用父类的：

方式1：

使用成员变量：父类名.成员变量

使用成员方法：父类名.成员方法(self)

方式2：使用super()

使用成员变量：super().成员变量

使用成员方法：super().成员方法()

**多态**：指多种状态，即完成某个行为时，使用不用的对象会得到不同的状态

比如：

· 函数（方法）形参声明接收父类对象

· 实际传入父类的子类对象进行工作

即：

· 以父类做定义声明

· 以子类做实际工作

· 用以获得同一行为，不同状态

**抽象类（接口）**

抽象类：含有抽象方法的类称之为抽象类

抽象方法：方法体是空实现的（pass）称之为抽象方法

父类来确定有哪些方法，由子类来具体实现——软性约束

-------------------------------------------------------------------------------------

**类型注解**：让Python明白这个成员的类型，方便提示和使用。

​		为**变量**设置类型注解：语法：		变量：类型

​		基础容器类型注解：   `my_list: list = [1, 2, 3]`

​		容器类型详细注解：	`my_list: list[int] = [1, 2, 3]`

元组类型设置类型详细注解，需要将每一个元素都标记出来										`my_touple: touple[str, int, bool] = ("itheima", 666, true)`

字典详细注解，需要2个类型，第一个是key，第二个是value

`my_dict: dict[str, int] = {"itheima": 666}`

​		也可以在注释中进行类型注解：

语法：#type: 类型		`var_1 = random. randint(1, 10)	#type: int`

一般，无法直接看出变量类型之时，会添加类型注解——提示型，错误时不会报错

**函数（方法）的类型注解 - 形参注解**

`def 函数方法名(形参名: 类型, 形参名: 类型, ......):`

​	`pass`

同时，函数（方法）的返回值也可以添加类型注解

`def 函数方法名(形参名: 类型, 形参名: 类型, ......)-> 返回值类型:`

​	`pass`

**Union类型**

`from typing import Union`

`my_list: list[Union[str, int]] = [1, 2, "itheima", "itcast"]`

`my_dict: dict[str, Union[str, int]] = {"name": "周洁轮", "age": 31}`

使用Union[类型, ... ...,类型]可以定义联合类型注解
